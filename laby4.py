# -*- coding: utf-8 -*-
"""laby4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jmbIqAYtAePtekv62js_dKzkp5BDOiu9
"""

import time
import multiprocessing as mp
import random
import math

# -----------------------------
# Funkcje TSP
# -----------------------------
def distance(city1, city2):
    return math.dist(city1, city2)

def route_length(route, cities):
    total = 0
    for i in range(len(route)):
        total += distance(cities[route[i - 1]], cities[route[i]])
    return total

# -----------------------------
# Selekcja, crossover, mutacja
# -----------------------------
def tournament_selection(population, fitness, k=3):
    selected = random.sample(range(len(population)), k)
    return population[min(selected, key=lambda i: fitness[i])]

def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [None]*size
    child[start:end] = parent1[start:end]
    pointer = 0
    for gene in parent2:
        if gene not in child:
            while child[pointer] is not None:
                pointer += 1
            child[pointer] = gene
    return child

def mutate(individual, mutation_rate):
    ind = individual[:]
    for i in range(len(ind)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(ind)-1)
            ind[i], ind[j] = ind[j], ind[i]
    return ind

# -----------------------------
# Wersja sekwencyjna
# -----------------------------
def genetic_algorithm_sequential(cities, initial_population, generations=200, mutation_rate=0.1):
    population = [ind[:] for ind in initial_population]
    for gen in range(generations):
        fitness = [route_length(ind, cities) for ind in population]

        new_population = []
        while len(new_population) < len(population):
            parent1 = tournament_selection(population, fitness)
            parent2 = tournament_selection(population, fitness)
            child = crossover(parent1, parent2)
            child = mutate(child, mutation_rate)
            new_population.append(child)

        population = new_population

    fitness = [route_length(ind, cities) for ind in population]
    best_idx = min(range(len(population)), key=lambda i: fitness[i])
    return population[best_idx], fitness[best_idx]

# -----------------------------
# Wersja równoległa
# -----------------------------
def generate_child(args):
    population, fitness, mutation_rate = args
    parent1 = tournament_selection(population, fitness)
    parent2 = tournament_selection(population, fitness)
    child = crossover(parent1, parent2)
    child = mutate(child, mutation_rate)
    return child

def genetic_algorithm_parallel_crossover(cities, initial_population, generations=200, mutation_rate=0.1):
    population = [ind[:] for ind in initial_population]
    n_processes = mp.cpu_count()
    with mp.Pool(n_processes) as pool:
        for gen in range(generations):
            # fitness nadal liczymy równolegle
            fitness = pool.starmap(route_length, [(ind, cities) for ind in population])

            # generowanie nowych osobników równolegle
            args = [(population, fitness, mutation_rate) for _ in range(len(population))]
            new_population = pool.map(generate_child, args)

            population = new_population

        # końcowy fitness
        fitness = pool.starmap(route_length, [(ind, cities) for ind in population])
    best_idx = min(range(len(population)), key=lambda i: fitness[i])
    return population[best_idx], fitness[best_idx]


# -----------------------------
# Test czasów
# -----------------------------
if __name__ == "__main__":
    num_cities = 200
    population_size = 200
    generations = 100

    # losowe miasta i populacja początkowa
    cities = [(random.random()*100, random.random()*100) for _ in range(num_cities)]
    initial_population = [random.sample(range(num_cities), num_cities) for _ in range(population_size)]

    # Czas wersji sekwencyjnej
    start = time.time()
    best_seq, best_seq_fit = genetic_algorithm_sequential(cities, initial_population, generations)
    end = time.time()
    print(f"Sequential GA time: {end - start:.2f} s")

    # Czas wersji równoległej
    start = time.time()
    best_par, best_par_fit = genetic_algorithm_parallel_crossover(cities, initial_population, generations)
    end = time.time()
    print(f"Parallel GA time: {end - start:.2f} s")